{
    "collab_server" : "",
    "contents" : "\n# helper for saveData function\n.convertNull <- function(x){\n  if (is.null(x)){\n    val <- NA\n  } else {\n    val <- x\n  }\n  val\n}\n\n# helper for create_page_list\n.revArgsGsub <- function(x, pattern, replacement){\n  # reverse input arguments for use in apply functions\n  gsub(pattern = pattern, replacement = replacement, x = x)\n}\n\n# helper for create_page\n.callTag <- function(index, pageList){\n  # identify tag and call it with the appropriate arguments\n  # define lists of possible inputs\n  tagList <- c(\"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\", \"p\")\n  multiList <- c(\"checkboxGroupInput\", \"radioButtons\")\n  textList <- c(\"passwordInput\", \"textInput\")\n  nusliList <- c(\"sliderInput\", \"numericInput\")\n\n  # check which function is matched to ensure correct use of arguments\n  if (any(tagList == pageList$type[index])){\n    if (substr(pageList$id[index], nchar(pageList$id[index]) - 1,\n               nchar(pageList$id[index])) == \"NA\"){\n      tempid <- NULL\n    } else {\n      tempid <- pageList$id[index]\n    }\n\n    # prints text, such as headers and paragraphs\n    getExportedValue(\"shiny\", pageList$type[index])(pageList$text[index],\n                                                    width = pageList$width[index],\n                                                    id = tempid)\n\n  } else if (any(multiList == pageList$type[index])){\n    # creates input objects such as radio buttons and multi check boxes.\n    getExportedValue(\"shiny\", pageList$type[index])(inputId = pageList$id[index],\n                                                    choices = pageList$choices[[index]],\n                                                    label = pageList$text[index],\n                                                    selected = character(0),\n                                                    width = pageList$width[index],\n                                                    inline = pageList$inline[index])\n\n  } else if (any(textList == pageList$type[index])){\n    # creates input objects such as password or text input.\n    getExportedValue(\"shiny\", pageList$type[index])(pageList$id[index],\n                                                    label = pageList$text[index],\n                                                    placeholder = pageList$placeholder[index],\n                                                    width = pageList$width[index])\n\n  } else if (any(nusliList == pageList$type[index])){\n    # creates input objects such as numeric input or slider\n    getExportedValue(\"shiny\", pageList$type[index])(pageList$id[index],\n                                                    label = pageList$text[index],\n                                                    min = pageList$min[index],\n                                                    max = pageList$max[index],\n                                                    value = pageList$choices[index],\n                                                    width = pageList$width[index])\n\n  } else if (pageList$type[index] == \"img\"){\n    # post an image from a given source\n    if (isTRUE(pageList$defaultList)){\n      shiny::addResourcePath('pictures', system.file('extdata', package='ShinyPsych'))\n    }\n    if (substr(pageList$id[index], nchar(pageList$id[index]) - 1,\n               nchar(pageList$id[index])) == \"NA\"){\n      tempid <- NULL\n    } else {\n      tempid <- pageList$id[index]\n    }\n    getExportedValue(\"shiny\", pageList$type[index])(src = pageList$text[index],\n                                                    width = pageList$width[index],\n                                                    height = pageList$height[index],\n                                                    id = tempid)\n\n  }else if (pageList$type[index] == \"HTML\"){\n\n    # this is apropriate if the text is actually written html code\n    shiny::HTML(pageList$text[index])\n\n  } else if (pageList$type[index] == \"checkboxInput\"){\n    # creates a checkbox that yields FALSE if unchecked and TRUE if checked\n    getExportedValue(\"shiny\", pageList$type[index])(pageList$id[index],\n                                                    label = pageList$text[index],\n                                                    width = pageList$width[index])\n\n  } else if (pageList$type[index] == \"selectInput\"){\n    # creates a dropdown list from which an input can be selected\n    getExportedValue(\"shiny\", pageList$type[index])(inputId = pageList$id[index],\n                                                    choices = pageList$choices[[index]],\n                                                    label = pageList$text[index],\n                                                    selected = character(0),\n                                                    width = pageList$width[index],\n                                                    multiple = pageList$inline[index])\n\n  } else {\n    # give exact value that raised the error\n    stop(\"Couldn't identify function. See documentation for valid inputs. Note that spelling must match shiny functions!\")\n  }\n}\n\n# helper for onInputEnable\n.checkInputFun <- function(Index, inList, checkType, charNum, checkInput){\n\n  if (checkType[Index] == \"isTRUE\"){\n\n    checkTemp <- !is.null(inList[[checkInput[Index]]]) &&\n      isTRUE(inList[[checkInput[Index]]])\n\n  } else if (checkType[Index] == \"is.null\"){\n\n    checkTemp <- !is.null(inList[[checkInput[Index]]])\n\n  } else if (checkType[Index] == \"nchar\"){\n\n    checkTemp <- !is.null(inList[[checkInput[Index]]]) &&\n      nchar(inList[[checkInput[Index]]]) >= charNum\n\n  } else {\n\n    stop(paste(checkType[Index],\n               \"is no valid checkType. Use one of \\\"isTRUE\\\", \\\"is.null\\\", \\\"nchar\\\"\"))\n  }\n\n  checkTemp\n\n}\n\n# helpers for createBanditList\n# sample values from normal distributions\n.getNormVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  round(rnorm(parList$nTrials[rowIndex], mean = parList$mean[rowIndex, colIndex],\n              sd = parList$sd[rowIndex, colIndex]), roundDigits)\n}\n\n.getNormVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getNormVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values form exponential distributions\n.getExpVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  round(rexp(parList$nTrials[rowIndex], rate = parList$rate[rowIndex, colIndex]),\n        roundDigits)\n}\n\n.getExpVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getExpVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values from uniform distributions\n.getUnifVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  round(runif(parList$nTrials[rowIndex], min = parList$min[rowIndex, colIndex],\n              max = parList$max[rowIndex, colIndex]), roundDigits)\n}\n\n.getUnifVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getUnifVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values from beta distributions\n.getBetaVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  round(rbeta(parList$nTrials[rowIndex],\n              shape1 = parList$shape1[rowIndex, colIndex],\n              shape2 = parList$shape2[rowIndex, colIndex],\n              ncp = parList$ncp[rowIndex, colIndex]), roundDigits)\n}\n\n.getBetaVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getBetaVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values from ex-gaussian distributions\n.getExgaussVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  round(retimes::rexgauss(parList$nTrials[rowIndex],\n                          mu = parList$mu[rowIndex, colIndex],\n                          sigma = parList$sigma[rowIndex, colIndex],\n                          tau = parList$tau[rowIndex, colIndex],\n                          positive = parList$positive[rowIndex, colIndex]),\n        roundDigits)\n}\n\n.getExgaussVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getExgaussVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values from different distributions\n.getDiffDistVals2 <- function(colIndex, rowIndex, parList, roundDigits){\n  if (parList$distributionType[rowIndex, colIndex] == \"normal\"){\n\n    round(rnorm(parList$nTrials[rowIndex], mean = parList$mean[rowIndex, colIndex],\n                sd = parList$sd[rowIndex, colIndex]), roundDigits)\n\n  } else if (parList$distributionType[rowIndex, colIndex] == \"exp\"){\n\n    round(rexp(parList$nTrials[rowIndex], rate = parList$rate[rowIndex, colIndex]),\n          roundDigits)\n\n  } else if (parList$distributionType[rowIndex, colIndex] == \"unif\"){\n\n    round(runif(parList$nTrials[rowIndex], min = parList$min[rowIndex, colIndex],\n                max = parList$max[rowIndex, colIndex]), roundDigits)\n\n  } else if (parList$distributionType[rowIndex, colIndex] == \"beta\") {\n\n    round(rbeta(parList$nTrials[rowIndex],\n                shape1 = parList$shape1[rowIndex, colIndex],\n                shape2 = parList$shape2[rowIndex, colIndex],\n                ncp = parList$ncp[rowIndex, colIndex]), roundDigits)\n\n  } else if (parList$distributionType[rowIndex, colIndex] == \"exgauss\"){\n\n    round(retimes::rexgauss(parList$nTrials[rowIndex],\n                            mu = parList$mu[rowIndex, colIndex],\n                            sigma = parList$sigma[rowIndex, colIndex],\n                            tau = parList$tau[rowIndex, colIndex],\n                            positive = parList$positive[rowIndex, colIndex]),\n          roundDigits)\n\n  } else {\n    stop(paste(parList$distributionType[rowIndex, colIndex], \"is no valid distribution type for this function. Must be one of \\\"normal\\\", \\\"exp\\\", \\\"unif\\\", \\\"beta\\\" or \\\"exgauss\\\"\"))\n  }\n\n}\n\n# sample values from different distributions for each option\n.getDiffDistVals1 <- function(gameIndex, distributionList, Arms, nDigits){\n  cbind(sapply(seq_len(Arms), .getDiffDistVals2, parList = distributionList,\n               rowIndex = gameIndex, roundDigits = nDigits))\n}\n\n# sample values from same distribution\n.getSameDistVals <- function(dList, armNumber, rDigits){\n  if (dList$distributionType == \"normal\"){\n\n    lapply(seq_along(dList$nTrials), .getNormVals1,\n           distributionList = dList, Arms = armNumber,\n           nDigits = rDigits)\n\n  } else if (dList$distributionType == \"exp\"){\n\n    lapply(seq_along(dList$nTrials), .getExpVals1,\n           distributionList = dList, Arms = armNumber,\n           nDigits = rDigits)\n\n  } else if (dList$distributionType == \"unif\"){\n\n    lapply(seq_along(dList$nTrials), .getUnifVals1,\n           distributionList = dList,Arms = armNumber,\n           nDigits = rDigits)\n\n  } else if (dList$distributionType == \"beta\") {\n\n    lapply(seq_along(dList$nTrials), .getBetaVals1,\n           distributionList = dList, Arms = armNumber,\n           nDigits = rDigits)\n\n  } else if (dList$distributionType == \"exgauss\"){\n\n    lapply(seq_along(dList$nTrials), .getExgaussVals1,\n           distributionList = dList, Arms = armNumber,\n           nDigits = rDigits)\n\n  } else {\n    stop(paste(dList$distributionType, \"is no valid distribution type for this function. Must be one of \\\"normal\\\", \\\"exp\\\", \\\"unif\\\", \\\"beta\\\" or \\\"exgauss\\\"\"))\n  }\n\n}\n\n# helper for createBartList\n\n.getPopVals <- function(index, distributionList){\n\n  if (distributionList$distributionType[index] == \"normal\"){\n\n    tempVals <- round(rnorm(distributionList$nBalloons[index],\n                mean = distributionList$mean[index],\n                sd = distributionList$sd[index]))\n\n    tempVals[tempVals > distributionList$max.pop[index]] <- distributionList$max.pop[index]\n\n  } else if (distributionList$distributionType[index] == \"exp\"){\n\n    tempVals <- round(rexp(distributionList$nBalloons[index],\n               rate = distributionList$rate[index]))\n\n    tempVals[tempVals > distributionList$max.pop[index]] <- distributionList$max.pop[index]\n\n  } else if (distributionList$distributionType[index] == \"unif\"){\n\n    tempVals <- round(runif(distributionList$nBalloons[index],\n                min = distributionList$min[index],\n                max = distributionList$max[index]))\n\n    tempVals[tempVals > distributionList$max.pop[index]] <- distributionList$max.pop[index]\n\n  } else if (distributionList$distributionType[index] == \"beta\") {\n\n    tempVals <- round(rbeta(distributionList$nBalloons[index],\n                shape1 = distributionList$shape1[index],\n                shape2 = distributionList$shape2[index],\n                ncp = distributionList$ncp[index]))\n\n    tempVals[tempVals > distributionList$max.pop[index]] <- distributionList$max.pop[index]\n\n  } else if (distributionList$distributionType[index] == \"exgauss\"){\n\n    tempVals <- round(retimes::rexgauss(distributionList$nBalloons[index],\n                            mu = distributionList$mu[index],\n                            sigma = distributionList$sigma[index],\n                            tau = distributionList$tau[index],\n                            positive = distributionList$positive[index]))\n\n    tempVals[tempVals > distributionList$max.pop[index]] <- distributionList$max.pop[index]\n    tempVals[tempVals < distributionList$min.pop[index]] <- distributionList$min.pop[index]\n\n  } else {\n    stop(paste(distributionList$distributionType[index], \"is no valid distribution type for this function. Must be one of \\\"normal\\\", \\\"exp\\\", \\\"unif\\\", \\\"beta\\\" or \\\"exgauss\\\"\"))\n  }\n\n  tempVals\n\n}\n\n\n# helper for createDfeList\n.getDfeSamples <- function(gambleInd, p.ind, o.ind, df, nOpt, nVals){\n\n  lapply(seq_len(nOpt), .drawSamples, Vals = nVals, gInd = gambleInd,\n         o.ind.vec = o.ind, p.ind.vec = p.ind, g.df = df)\n\n}\n\n.drawSamples <- function(optInd, gInd, Vals, o.ind.vec, p.ind.vec, g.df){\n\n  outc.temp <- unlist(unname(g.df[gInd, o.ind.vec[grepl(paste0(\"g\", optInd),\n                                                        o.ind.vec)]]))\n\n  outc.temp <- outc.temp[!is.na(outc.temp)]\n\n  prob.temp <- unlist(unname(g.df[gInd, p.ind.vec[grepl(paste0(\"g\", optInd),\n                                                        p.ind.vec)]]))\n\n  prob.temp <- prob.temp[!is.na(prob.temp)]\n\n  if (sum(prob.temp) != 1){\n    stop(paste(\"In gamble number\", gInd, \"option number\", optInd,\n               \"probabilities do not add to 1.\"))\n  }\n\n  if (length(outc.temp) == 1){\n    temp.vals <- rep(outc.temp, Vals)\n  } else {\n    temp.vals <- sample(outc.temp, size = Vals, prob = prob.temp, replace = TRUE)\n  }\n\n  temp.vals\n}\n\n\n# helper for createDfdList\n.getDfdGambles <- function(gambleInd, p.ind, o.ind, df, nOpt, currency, nOutc){\n\n\n  lapply(seq_len(nOpt), .printDfdGamble, gInd = gambleInd,\n         o.ind.vec = o.ind, p.ind.vec = p.ind, g.df = df,\n         currency.i = currency, mRows = nOutc)\n\n}\n\n\n.printDfdGamble <- function(optInd, gInd, o.ind.vec, p.ind.vec, g.df, currency.i,\n                           mRows){\n\n  # prepare vectors of outcomes and probabilities\n  outc.temp <- unlist(unname(g.df[gInd, o.ind.vec[grepl(paste0(\"g\", optInd),\n                                                        o.ind.vec)]]))\n\n  outc.temp <- outc.temp[!is.na(outc.temp)]\n\n  prob.temp <- unlist(unname(g.df[gInd, p.ind.vec[grepl(paste0(\"g\", optInd),\n                                                        p.ind.vec)]]))\n\n  prob.temp <- prob.temp[!is.na(prob.temp)]\n\n  outc.temp <- outc.temp[prob.temp != 0]\n  prob.temp <- prob.temp[prob.temp != 0]\n\n  if (sum(prob.temp) != 1){\n    stop(paste(\"In gamble number\", gInd, \"option number\", optInd,\n               \"probabilities do not add to 1.\"))\n  }\n\n  # paste gamble outcomes and probabilities into html tags to create a table\n  printedGamble <- paste(\n    unlist(lapply(seq_len(mRows),\n                  function(x, outc.t, prob.t, curr){\n                    if (x <= length(prob.t)){\n                      paste0(\"<tr><td>\", outc.t[x], curr, \"</td><td>\",\n                            prob.t[x] * 100, \"%</td></tr>\")\n                    } else {\n                      paste(\"<tr class = 'emptyRow'><td> e </td>\",\n                            \"<td> e </td></tr>\")\n                    }\n                  }, outc.t = outc.temp, prob.t = prob.temp,\n                  curr = currency.i)), collapse = \"\")\n\n  printedGamble\n}\n\n\n# helper for createDdList\n.getDdOutcomes <- function(rowInd, df, nOpt, currency){\n\n  lapply(seq_len(nOpt), .printDdTrial, rInd = rowInd,\n         dd.df = df, currency.i = currency)\n\n}\n\n\n.printDdTrial <- function(optInd, rInd, dd.df, currency.i){\n\n  # paste gamble outcomes and probabilities into html tags to create a table\n  printedGamble <- paste0(\"<tr><td>\", dd.df[rInd, paste0(\"o\", optInd)],\n                          currency.i, \"</td></tr><tr><td>\",\n                          dd.df[rInd, paste0(\"time\", optInd)], \"</td></tr>\")\n\n  printedGamble\n}\n",
    "created" : 1503387267544.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2296742961",
    "id" : "88CB6ED3",
    "lastKnownWriteTime" : 1503992350,
    "last_content_update" : 1503992350828,
    "path" : "C:/Users/Markus/switchdrive/ShinyPsych/R/helper.R",
    "project_path" : "R/helper.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}